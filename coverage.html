
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aleksandr/strive-api/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/aleksandr/strive-api/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/aleksandr/strive-api/internal/database/database.go (0.0%)</option>
				
				<option value="file3">github.com/aleksandr/strive-api/internal/http/auth_handlers.go (80.6%)</option>
				
				<option value="file4">github.com/aleksandr/strive-api/internal/http/auth_middleware.go (84.0%)</option>
				
				<option value="file5">github.com/aleksandr/strive-api/internal/http/handlers.go (100.0%)</option>
				
				<option value="file6">github.com/aleksandr/strive-api/internal/http/middleware.go (100.0%)</option>
				
				<option value="file7">github.com/aleksandr/strive-api/internal/http/server.go (0.0%)</option>
				
				<option value="file8">github.com/aleksandr/strive-api/internal/logger/logger.go (0.0%)</option>
				
				<option value="file9">github.com/aleksandr/strive-api/internal/migrate/migrate.go (0.0%)</option>
				
				<option value="file10">github.com/aleksandr/strive-api/internal/repositories/user_repository.go (0.0%)</option>
				
				<option value="file11">github.com/aleksandr/strive-api/internal/services/auth_service.go (72.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"

        "github.com/aleksandr/strive-api/internal/config"
        "github.com/aleksandr/strive-api/internal/database"
        httphandler "github.com/aleksandr/strive-api/internal/http"
        "github.com/aleksandr/strive-api/internal/logger"
        "github.com/aleksandr/strive-api/internal/migrate"
        "github.com/aleksandr/strive-api/internal/repositories"
        "github.com/aleksandr/strive-api/internal/services"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">logger := logger.New(cfg.Log.Level, cfg.Log.Format)
        logger.Info("Application starting", "config", cfg)

        if err := migrate.Run(cfg, logger); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to run migrations: %v", err)
        }</span>

        <span class="cov0" title="0">db, err := database.New(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Initialize repositories and services
        userRepo := repositories.NewUserRepository(db.Pool())
        authService := services.NewAuthService(userRepo, cfg.JWT.Secret)

        // Initialize handlers
        authHandlers := httphandler.NewAuthHandlers(authService, logger)

        mux := http.NewServeMux()

        // Public routes
        mux.HandleFunc("/health", httphandler.HealthHandler)
        mux.HandleFunc("/api/v1/auth/register", authHandlers.Register)
        mux.HandleFunc("/api/v1/auth/login", authHandlers.Login)

        // Protected routes (example)
        protectedMux := http.NewServeMux()
        protectedMux.HandleFunc("/api/v1/user/profile", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(`{"message":"This is a protected endpoint"}`))
        }</span>)

        // Apply middleware to protected routes
        <span class="cov0" title="0">protectedHandler := httphandler.LoggingMiddleware(logger)(
                httphandler.RequestIDMiddleware()(
                        httphandler.AuthMiddleware(authService)(protectedMux),
                ),
        )

        // Combine public and protected routes
        mux.Handle("/api/v1/user/", http.StripPrefix("/api/v1/user", protectedHandler))

        // Apply middleware to main mux
        handler := httphandler.LoggingMiddleware(logger)(httphandler.RequestIDMiddleware()(mux))

        server := httphandler.NewServer(cfg, handler, logger)
        server.Start()
        server.WaitForShutdown()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"
)

type Config struct {
        Server ServerConfig
        Log    LogConfig
        DB     DatabaseConfig
        JWT    JWTConfig
}

type ServerConfig struct {
        Port         int
        ReadTimeout  time.Duration
        WriteTimeout time.Duration
        IdleTimeout  time.Duration
}

type LogConfig struct {
        Level  string
        Format string
}

type DatabaseConfig struct {
        Host     string
        Port     int
        User     string
        Password string
        DBName   string
        SSLMode  string
        MaxConns int32
        MinConns int32
}

type JWTConfig struct {
        Secret string
}

func Load() (*Config, error) <span class="cov0" title="0">{
        config := &amp;Config{
                Server: ServerConfig{
                        Port:         getEnvInt("PORT", 8080),
                        ReadTimeout:  getEnvDuration("SERVER_READ_TIMEOUT", 10*time.Second),
                        WriteTimeout: getEnvDuration("SERVER_WRITE_TIMEOUT", 10*time.Second),
                        IdleTimeout:  getEnvDuration("SERVER_IDLE_TIMEOUT", 60*time.Second),
                },
                Log: LogConfig{
                        Level:  getEnv("LOG_LEVEL", "INFO"),
                        Format: getEnv("LOG_FORMAT", "json"),
                },
                DB: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "localhost"),
                        Port:     getEnvInt("DB_PORT", 5432),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", "password"),
                        DBName:   getEnv("DB_NAME", "strive"),
                        SSLMode:  getEnv("DB_SSL_MODE", "disable"),
                        MaxConns: int32(getEnvInt("DB_MAX_CONNS", 25)),
                        MinConns: int32(getEnvInt("DB_MIN_CONNS", 5)),
                },
                JWT: JWTConfig{
                        Secret: getEnv("JWT_SECRET", "your-secret-key-change-in-production"),
                },
        }

        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Server.Port &lt;= 0 || c.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port: %d", c.Server.Port)
        }</span>

        <span class="cov0" title="0">validLevels := map[string]bool{
                "DEBUG": true,
                "INFO":  true,
                "WARN":  true,
                "ERROR": true,
        }
        if !validLevels[c.Log.Level] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %s", c.Log.Level)
        }</span>

        <span class="cov0" title="0">validFormats := map[string]bool{
                "json": true,
                "text": true,
        }
        if !validFormats[c.Log.Format] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log format: %s", c.Log.Format)
        }</span>

        <span class="cov0" title="0">if c.DB.Port &lt;= 0 || c.DB.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database port: %d", c.DB.Port)
        }</span>

        <span class="cov0" title="0">if c.DB.MaxConns &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid max connections: %d", c.DB.MaxConns)
        }</span>

        <span class="cov0" title="0">if c.DB.MinConns &lt; 0 || c.DB.MinConns &gt; c.DB.MaxConns </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid min connections: %d", c.DB.MinConns)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Config) DatabaseURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=%s",
                c.DB.User, c.DB.Password, c.DB.Host, c.DB.Port, c.DB.DBName, c.DB.SSLMode)
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/aleksandr/strive-api/internal/config"
        "github.com/aleksandr/strive-api/internal/logger"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Database struct {
        pool   *pgxpool.Pool
        logger *logger.Logger
}

func New(cfg *config.Config, log *logger.Logger) (*Database, error) <span class="cov0" title="0">{
        poolConfig, err := pgxpool.ParseConfig(cfg.DatabaseURL())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse database URL: %w", err)
        }</span>

        <span class="cov0" title="0">poolConfig.MaxConns = cfg.DB.MaxConns
        poolConfig.MinConns = cfg.DB.MinConns
        poolConfig.MaxConnLifetime = time.Hour
        poolConfig.MaxConnIdleTime = time.Minute * 30

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection pool: %w", err)
        }</span>

        <span class="cov0" title="0">if err := pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("Database connected successfully",
                "host", cfg.DB.Host,
                "port", cfg.DB.Port,
                "database", cfg.DB.DBName,
                "max_conns", cfg.DB.MaxConns,
                "min_conns", cfg.DB.MinConns,
        )

        return &amp;Database{
                pool:   pool,
                logger: log,
        }, nil</span>
}

func (db *Database) Pool() *pgxpool.Pool <span class="cov0" title="0">{
        return db.pool
}</span>

func (db *Database) Close() <span class="cov0" title="0">{
        db.pool.Close()
        db.logger.Info("Database connection pool closed")
}</span>

func (db *Database) Health(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        return db.pool.Ping(ctx)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/aleksandr/strive-api/internal/logger"
        "github.com/aleksandr/strive-api/internal/models"
        "github.com/aleksandr/strive-api/internal/services"
)

type AuthHandlers struct {
        authService services.AuthService
        logger      *logger.Logger
}

func NewAuthHandlers(authService services.AuthService, logger *logger.Logger) *AuthHandlers <span class="cov10" title="6">{
        return &amp;AuthHandlers{
                authService: authService,
                logger:      logger,
        }
}</span>

type RegisterRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=8"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type AuthResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int    `json:"expires_in"`
        TokenType    string `json:"token_type"`
}

type ErrorResponse struct {
        Error struct {
                Code    string `json:"code"`
                Message string `json:"message"`
        } `json:"error"`
}

func (h *AuthHandlers) Register(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        var req RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode register request", "error", err)
                http.Error(w, `{"error":{"code":"INVALID_REQUEST","message":"Invalid JSON"}}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="3">createReq := &amp;models.CreateUserRequest{
                Email:    req.Email,
                Password: req.Password,
        }

        user, err := h.authService.Register(r.Context(), createReq)
        if err != nil </span><span class="cov4" title="2">{
                h.logger.Error("Failed to register user", "error", err, "email", req.Email)
                http.Error(w, `{"error":{"code":"REGISTRATION_FAILED","message":"Failed to register user"}}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">h.logger.Info("User registered successfully", "user_id", user.ID, "email", user.Email)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "message": "User registered successfully",
                "user_id": user.ID,
        })</span>
}

func (h *AuthHandlers) Login(w http.ResponseWriter, r *http.Request) <span class="cov6" title="3">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode login request", "error", err)
                http.Error(w, `{"error":{"code":"INVALID_REQUEST","message":"Invalid JSON"}}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov6" title="3">accessToken, refreshToken, err := h.authService.Login(r.Context(), req.Email, req.Password)
        if err != nil </span><span class="cov4" title="2">{
                h.logger.Error("Failed to login user", "error", err, "email", req.Email)
                http.Error(w, `{"error":{"code":"INVALID_CREDENTIALS","message":"Invalid email or password"}}`, http.StatusUnauthorized)
                return
        }</span>

        <span class="cov1" title="1">h.logger.Info("User logged in successfully", "email", req.Email)

        response := AuthResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    900, // 15 minutes
                TokenType:    "Bearer",
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import (
        "context"
        "net/http"
        "strings"

        "github.com/aleksandr/strive-api/internal/services"
)

type contextKey string

const UserIDKey contextKey = "user_id"
const UserEmailKey contextKey = "user_email"

func AuthMiddleware(authService services.AuthService) func(http.Handler) http.Handler <span class="cov10" title="6">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="6">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="6">{
                        authHeader := r.Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov1" title="1">{
                                http.Error(w, `{"error":{"code":"UNAUTHORIZED","message":"Authorization header required"}}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov9" title="5">parts := strings.SplitN(authHeader, " ", 2)
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov1" title="1">{
                                http.Error(w, `{"error":{"code":"INVALID_TOKEN","message":"Bearer token required"}}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov7" title="4">tokenString := parts[1]
                        if tokenString == "" </span><span class="cov1" title="1">{
                                http.Error(w, `{"error":{"code":"EMPTY_TOKEN","message":"Token cannot be empty"}}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov6" title="3">claims, err := authService.ValidateToken(tokenString)
                        if err != nil </span><span class="cov1" title="1">{
                                http.Error(w, `{"error":{"code":"INVALID_TOKEN","message":"Invalid or expired token"}}`, http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov4" title="2">ctx := context.WithValue(r.Context(), UserIDKey, claims.UserID)
                        ctx = context.WithValue(ctx, UserEmailKey, claims.Email)

                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

func GetUserIDFromContext(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        userID, ok := ctx.Value(UserIDKey).(string)
        return userID, ok
}</span>

func GetUserEmailFromContext(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        email, ok := ctx.Value(UserEmailKey).(string)
        return email, ok
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package http

import (
        "encoding/json"
        "net/http"
)

type HealthResponse struct {
        Status string `json:"status"`
}

func HealthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(HealthResponse{Status: "ok"})
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        "context"
        "net/http"
        "strconv"
        "time"

        "github.com/aleksandr/strive-api/internal/logger"
        "github.com/google/uuid"
)

type loggingResponseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (lrw *loggingResponseWriter) WriteHeader(code int) <span class="cov5" title="2">{
        lrw.statusCode = code
        lrw.ResponseWriter.WriteHeader(code)
}</span>

func (lrw *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov5" title="2">{
        return lrw.ResponseWriter.Write(b)
}</span>

func LoggingMiddleware(log *logger.Logger) func(http.Handler) http.Handler <span class="cov5" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov5" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov5" title="2">{
                        requestID := r.Header.Get("X-Request-ID")
                        if requestID == "" </span><span class="cov5" title="2">{
                                requestID = uuid.New().String()
                        }</span>

                        <span class="cov5" title="2">start := time.Now()

                        lrw := &amp;loggingResponseWriter{
                                ResponseWriter: w,
                                statusCode:     http.StatusOK,
                        }

                        ctx := logger.WithContext(r.Context(), log.WithRequestID(requestID))
                        r = r.WithContext(ctx)

                        next.ServeHTTP(lrw, r)

                        duration := time.Since(start)
                        durationStr := strconv.FormatFloat(duration.Seconds(), 'f', 3, 64) + "s"

                        log.LogRequest(r.Method, r.URL.Path, lrw.statusCode, durationStr, requestID)</span>
                })
        }
}

func RequestIDMiddleware() func(http.Handler) http.Handler <span class="cov10" title="4">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="4">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="4">{
                        requestID := r.Header.Get("X-Request-ID")
                        if requestID == "" </span><span class="cov8" title="3">{
                                requestID = uuid.New().String()
                        }</span>

                        <span class="cov10" title="4">ctx := context.WithValue(r.Context(), "request_id", requestID)
                        w.Header().Set("X-Request-ID", requestID)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package http

import (
        "context"
        "log"
        "net/http"
        "os/signal"
        "strconv"
        "syscall"
        "time"

        "github.com/aleksandr/strive-api/internal/config"
        "github.com/aleksandr/strive-api/internal/logger"
)

type Server struct {
        httpServer *http.Server
        logger     *logger.Logger
}

func NewServer(cfg *config.Config, handler http.Handler, log *logger.Logger) *Server <span class="cov0" title="0">{
        return &amp;Server{
                httpServer: &amp;http.Server{
                        Addr:              ":" + strconv.Itoa(cfg.Server.Port),
                        Handler:           handler,
                        ReadHeaderTimeout: 5 * time.Second,
                        ReadTimeout:       cfg.Server.ReadTimeout,
                        WriteTimeout:      cfg.Server.WriteTimeout,
                        IdleTimeout:       cfg.Server.IdleTimeout,
                },
                logger: log,
        }
}</span>

func (s *Server) Start() <span class="cov0" title="0">{
        s.logger.Info("Starting server", "addr", s.httpServer.Addr)
        go func() </span><span class="cov0" title="0">{
                if err := s.httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Error("Server error", "error", err)
                        log.Fatalf("server error: %v", err)
                }</span>
        }()
}

func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return s.httpServer.Shutdown(ctx)
}</span>

func (s *Server) WaitForShutdown() <span class="cov0" title="0">{
        shutdownCtx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        defer stop()

        &lt;-shutdownCtx.Done()
        s.logger.Info("Shutdown signal received")

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := s.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Graceful shutdown failed", "error", err)
                log.Printf("graceful shutdown failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Info("Server stopped gracefully")
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "os"
        "strings"
)

type Logger struct {
        *slog.Logger
}

func New(level, format string) *Logger <span class="cov0" title="0">{
        var logLevel slog.Level
        switch strings.ToUpper(level) </span>{
        case "DEBUG":<span class="cov0" title="0">
                logLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "WARN":<span class="cov0" title="0">
                logLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        }

        <span class="cov0" title="0">var handler slog.Handler
        if strings.ToLower(format) == "json" </span><span class="cov0" title="0">{
                handler = slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: logLevel,
                })
        }</span> else<span class="cov0" title="0"> {
                handler = slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: logLevel,
                })
        }</span>

        <span class="cov0" title="0">return &amp;Logger{
                Logger: slog.New(handler),
        }</span>
}

func (l *Logger) WithRequestID(requestID string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                Logger: l.Logger.With("request_id", requestID),
        }
}</span>

func (l *Logger) LogRequest(method, path string, statusCode int, duration string, requestID string) <span class="cov0" title="0">{
        l.WithRequestID(requestID).Info("HTTP request",
                "method", method,
                "path", path,
                "status", statusCode,
                "duration", duration,
        )
}</span>

func (l *Logger) LogError(err error, msg string, requestID string) <span class="cov0" title="0">{
        l.WithRequestID(requestID).Error(msg, "error", err.Error())
}</span>

type LogEntry struct {
        Level     string      `json:"level"`
        Message   string      `json:"message"`
        Timestamp string      `json:"timestamp"`
        RequestID string      `json:"request_id,omitempty"`
        Fields    interface{} `json:"fields,omitempty"`
}

func (l *Logger) LogStructured(level, message string, fields map[string]interface{}, requestID string) <span class="cov0" title="0">{
        entry := LogEntry{
                Level:     level,
                Message:   message,
                Timestamp: fmt.Sprintf("%d", os.Getpid()),
                Fields:    fields,
        }

        if requestID != "" </span><span class="cov0" title="0">{
                entry.RequestID = requestID
        }</span>

        <span class="cov0" title="0">jsonData, _ := json.Marshal(entry)
        fmt.Println(string(jsonData))</span>
}

func FromContext(ctx context.Context) *Logger <span class="cov0" title="0">{
        if logger, ok := ctx.Value("logger").(*Logger); ok </span><span class="cov0" title="0">{
                return logger
        }</span>
        <span class="cov0" title="0">return New("INFO", "json")</span>
}

func WithContext(ctx context.Context, logger *Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, "logger", logger)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package migrate

import (
        "database/sql"
        "fmt"
        "path/filepath"

        "github.com/aleksandr/strive-api/internal/config"
        "github.com/aleksandr/strive-api/internal/logger"
        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/jackc/pgx/v5/stdlib"
)

func Run(cfg *config.Config, log *logger.Logger) error <span class="cov0" title="0">{
        db, err := sql.Open("pgx", cfg.DatabaseURL())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create postgres driver: %w", err)
        }</span>

        <span class="cov0" title="0">migrationsPath := filepath.Join("migrations")
        sourceURL := fmt.Sprintf("file://%s", migrationsPath)

        m, err := migrate.NewWithDatabaseInstance(sourceURL, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>
        <span class="cov0" title="0">defer m.Close()

        log.Info("Running database migrations", "path", migrationsPath)

        if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to run migrations: %w", err)
        }</span>

        <span class="cov0" title="0">version, dirty, err := m.Version()
        if err != nil &amp;&amp; err != migrate.ErrNilVersion </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get migration version: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("Database migrations completed successfully",
                "version", version,
                "dirty", dirty,
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repositories

import (
        "context"
        "fmt"

        "github.com/aleksandr/strive-api/internal/models"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgxpool"
)

type UserRepository interface {
        Create(ctx context.Context, user *models.User) error
        GetByID(ctx context.Context, id uuid.UUID) (*models.User, error)
        GetByEmail(ctx context.Context, email string) (*models.User, error)
        Update(ctx context.Context, user *models.User) error
        Delete(ctx context.Context, id uuid.UUID) error
}

type userRepository struct {
        pool *pgxpool.Pool
}

func NewUserRepository(pool *pgxpool.Pool) UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                pool: pool,
        }
}</span>

func (r *userRepository) Create(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (id, email, password_hash, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5)
        `

        _, err := r.pool.Exec(ctx, query, user.ID, user.Email, user.PasswordHash, user.CreatedAt, user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, email, password_hash, created_at, updated_at
                FROM users
                WHERE id = $1
        `

        user := &amp;models.User{}
        err := r.pool.QueryRow(ctx, query, id).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.PasswordHash,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by id: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, email, password_hash, created_at, updated_at
                FROM users
                WHERE email = $1
        `

        user := &amp;models.User{}
        err := r.pool.QueryRow(ctx, query, email).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.PasswordHash,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by email: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *userRepository) Update(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users
                SET email = $2, password_hash = $3, updated_at = $4
                WHERE id = $1
        `

        _, err := r.pool.Exec(ctx, query, user.ID, user.Email, user.PasswordHash, user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = $1`

        _, err := r.pool.Exec(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/aleksandr/strive-api/internal/models"
        "github.com/aleksandr/strive-api/internal/repositories"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type AuthService interface {
        Register(ctx context.Context, req *models.CreateUserRequest) (*models.User, error)
        Login(ctx context.Context, email, password string) (string, string, error)
        ValidateToken(tokenString string) (*Claims, error)
        HashPassword(password string) (string, error)
        VerifyPassword(hashedPassword, password string) error
}

type Claims struct {
        UserID uuid.UUID `json:"user_id"`
        Email  string    `json:"email"`
        jwt.RegisteredClaims
}

type authService struct {
        userRepo   repositories.UserRepository
        jwtSecret  string
        accessTTL  time.Duration
        refreshTTL time.Duration
}

func NewAuthService(userRepo repositories.UserRepository, jwtSecret string) AuthService <span class="cov10" title="4">{
        return &amp;authService{
                userRepo:   userRepo,
                jwtSecret:  jwtSecret,
                accessTTL:  15 * time.Minute,
                refreshTTL: 7 * 24 * time.Hour,
        }
}</span>

func (s *authService) Register(ctx context.Context, req *models.CreateUserRequest) (*models.User, error) <span class="cov8" title="3">{
        existingUser, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with email %s already exists", req.Email)
        }</span>

        <span class="cov8" title="3">hashedPassword, err := s.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov8" title="3">user := &amp;models.User{
                ID:           uuid.New(),
                Email:        req.Email,
                PasswordHash: hashedPassword,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }

        if err := s.userRepo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov8" title="3">return user, nil</span>
}

func (s *authService) Login(ctx context.Context, email, password string) (string, string, error) <span class="cov5" title="2">{
        user, err := s.userRepo.GetByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid credentials")
        }</span>

        <span class="cov5" title="2">if err := s.VerifyPassword(user.PasswordHash, password); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid credentials")
        }</span>

        <span class="cov5" title="2">accessToken, err := s.generateToken(user, s.accessTTL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov5" title="2">refreshToken, err := s.generateToken(user, s.refreshTTL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov5" title="2">return accessToken, refreshToken, nil</span>
}

func (s *authService) ValidateToken(tokenString string) (*Claims, error) <span class="cov1" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov1" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov1" title="1">return []byte(s.jwtSecret), nil</span>
        })

        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov1" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov1" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

func (s *authService) HashPassword(password string) (string, error) <span class="cov10" title="4">{
        hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov10" title="4">return string(hashedBytes), nil</span>
}

func (s *authService) VerifyPassword(hashedPassword, password string) error <span class="cov10" title="4">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>

func (s *authService) generateToken(user *models.User, ttl time.Duration) (string, error) <span class="cov10" title="4">{
        claims := &amp;Claims{
                UserID: user.ID,
                Email:  user.Email,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(ttl)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
